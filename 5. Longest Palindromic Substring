/*
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example:

Input: "babad"

Output: "bab"

Note: "aba" is also a valid answer.
Example:

Input: "cbbd"

Output: "bb"
*/

int oddSearch(char *s , int mid , int slen) {
    int dis = 0;
    //int head = mid - dis;
    //int tail = mid + dis;
    int substringset = 0;
    while ((mid - dis > 0) && (mid + dis < slen - 1) && (!substringset)) {
        if (s[mid - dis] == s[mid + dis]) {
            dis++;
        }
        else {
            dis--;
            substringset = 1;
        }           
    } // extend odd palindrome substring. stop when head == 0 or tail == end or no more palindrome property.
    if (((mid - dis == 0) || (mid + dis == slen - 1)) && (s[mid - dis] != s[mid + dis])) {
            dis--;  
    }  // check the edge is in the substring.        
    return dis;    
}

int evenSearch(char *s , int mid , int slen) {
    int dis = 0;
    //int head = mid - dis;
    //int tail = mid + 1 + dis;
    int substringset = 0;
    while ((mid - dis > 0) && (mid + 1 + dis < slen - 1) && (!substringset)) {
        if (s[mid - dis] == s[mid + 1 + dis]) {
            dis++;
        }
        else {
            dis--;
            substringset = 1;
        }           
    } // extend odd palindrome substring. stop when head == 0 or tail == end or no more palindrome property.
    if (((mid - dis == 0) || (mid + 1 + dis == slen - 1)) && (s[mid - dis] != s[mid + 1 + dis])) {
        dis--;
    }// check the edge is in the substring.
    return dis;    
}
char* longestPalindrome(char* s) {
    if (*s == NULL) return NULL;
    int slen = strlen(s);
    printf("slen = %d.\n",slen);    
    if (slen == 1) return s;
    int maxlen = 1;
    char *answer = (char *) malloc(sizeof(char) * slen + 1);
    answer[0] = s[0]; answer[1] = NULL;
    for(int i = 1; i < slen - 1; i++)
    {
        int templen = 0;
        int tempdis = 0;
        tempdis = oddSearch(s , i , slen);
        templen = tempdis * 2 + 1;
        if (templen > maxlen) {
            maxlen = templen;
            answer[tempdis] = s[i];
            int dis = tempdis;
            while(dis > 0) {
                answer[tempdis - dis] = s[i - dis];
                answer[tempdis + dis] = s[i + dis];
                dis--;
            }
            answer[maxlen] = NULL;
        }
    }
    
    for(int i = 0; i < slen - 1; i++)
    {
        int templen = 0;
        int tempdis = 0;
        tempdis = evenSearch(s , i , slen);
        templen = tempdis * 2 + 2;
        if (templen > maxlen) {
            maxlen = templen;
            answer[tempdis] = s[i];
            answer[tempdis + 1] = s[i + 1];
            int dis = tempdis;
            while(dis > 0) {
                answer[tempdis - dis] = s[i - dis];
                answer[tempdis + 1 + dis] = s[i + 1 + dis];
                dis--;
            }
            answer[maxlen] = NULL;
        }        
    }
        
    return answer;
    
}
